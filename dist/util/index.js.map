{"version":3,"file":"index.js","sources":["../../src/util/debounce.js","../../src/util/hasAccessor.js","../../src/util/hash/hashCode.js","../../src/util/hash/uuidv4.js","../../src/util/style/styleParsePixels.js","../../src/util/svelte/applicationShellContract.js","../../src/util/svelte/isApplicationShell.js","../../src/util/svelte/isSvelteComponent.js","../../src/util/svelte/outroAndDestroy.js","../../src/util/svelte/parseSvelteConfig.js","../../node_modules/@typhonjs-utils/object/src/functions.js"],"sourcesContent":["/**\r\n * Wraps a callback in a debounced timeout.\r\n *\r\n * Delay execution of the callback function until the function has not been called for the given delay in milliseconds.\r\n *\r\n * @param {Function} callback - A function to execute once the debounced threshold has been passed.\r\n *\r\n * @param {number}   delay - An amount of time in milliseconds to delay.\r\n *\r\n * @return {Function} A wrapped function that can be called to debounce execution.\r\n */\r\nexport function debounce(callback, delay)\r\n{\r\n   let timeoutId;\r\n\r\n   return function(...args)\r\n   {\r\n      clearTimeout(timeoutId);\r\n      timeoutId = setTimeout(() => { callback.apply(this, args) }, delay);\r\n   }\r\n}\r\n","/**\r\n * Provides a method to determine if the passed in Svelte component has a getter accessor.\r\n *\r\n * @param {*}        component - Svelte component.\r\n *\r\n * @param {string}   accessor - Accessor to test.\r\n *\r\n * @returns {boolean} Whether the component has the getter for accessor.\r\n */\r\nexport function hasGetter(component, accessor)\r\n{\r\n   if (component === null || component === void 0) { return false; }\r\n\r\n   // Get the prototype which is the parent SvelteComponent that has any getter / setters.\r\n   const prototype = Object.getPrototypeOf(component);\r\n   const descriptor = Object.getOwnPropertyDescriptor(prototype, accessor);\r\n\r\n   return !(descriptor === void 0 || descriptor.get === void 0);\r\n}\r\n\r\n/**\r\n * Provides a method to determine if the passed in Svelte component has a getter & setter accessor.\r\n *\r\n * @param {*}        component - Svelte component.\r\n *\r\n * @param {string}   accessor - Accessor to test.\r\n *\r\n * @returns {boolean} Whether the component has the getter and setter for accessor.\r\n */\r\nexport function hasAccessor(component, accessor)\r\n{\r\n   if (component === null || component === void 0) { return false; }\r\n\r\n   // Get the prototype which is the parent SvelteComponent that has any getter / setters.\r\n   const prototype = Object.getPrototypeOf(component);\r\n   const descriptor = Object.getOwnPropertyDescriptor(prototype, accessor);\r\n\r\n   return !(descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0);\r\n}\r\n\r\n/**\r\n * Provides a method to determine if the passed in Svelte component has a setter accessor.\r\n *\r\n * @param {*}        component - Svelte component.\r\n *\r\n * @param {string}   accessor - Accessor to test.\r\n *\r\n * @returns {boolean} Whether the component has the setter for accessor.\r\n */\r\nexport function hasSetter(component, accessor)\r\n{\r\n   if (component === null || component === void 0) { return false; }\r\n\r\n   // Get the prototype which is the parent SvelteComponent that has any getter / setters.\r\n   const prototype = Object.getPrototypeOf(component);\r\n   const descriptor = Object.getOwnPropertyDescriptor(prototype, accessor);\r\n\r\n   return !(descriptor === void 0 || descriptor.set === void 0);\r\n}","/**\r\n * Provides a solid string hashing algorithm.\r\n *\r\n * Sourced from: https://stackoverflow.com/a/52171480\r\n *\r\n * @param {string}   str - String to hash.\r\n *\r\n * @param {number}   seed - A seed value altering the hash.\r\n *\r\n * @returns {number} Hash code.\r\n */\r\nexport function hashCode(str, seed = 0)\r\n{\r\n   if (typeof str !== 'string') { return 0; }\r\n\r\n   let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\r\n\r\n   for (let ch, i = 0; i < str.length; i++)\r\n   {\r\n      ch = str.charCodeAt(i);\r\n      h1 = Math.imul(h1 ^ ch, 2654435761);\r\n      h2 = Math.imul(h2 ^ ch, 1597334677);\r\n   }\r\n\r\n   h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);\r\n   h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);\r\n\r\n   return 4294967296 * (2097151 & h2) + (h1 >>> 0);\r\n}\r\n","/**\r\n * Generates a UUID v4 compliant ID. Please use a complete UUID generation package for guaranteed compliance.\r\n *\r\n * This code is an evolution of the following Gist.\r\n * https://gist.github.com/jed/982883\r\n *\r\n * There is a public domain / free copy license attached to it that is not a standard OSS license...\r\n * https://gist.github.com/jed/982883#file-license-txt\r\n *\r\n * @returns {string} UUIDv4\r\n */\r\nexport function uuidv4()\r\n{\r\n   return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>\r\n    (c ^ (globalThis.crypto || globalThis.msCrypto).getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));\r\n}\r\n","const s_REGEX = /(\\d+)\\s*px/;\r\n\r\n/**\r\n * Parses a pixel string / computed styles. Ex. `100px` returns `100`.\r\n *\r\n * @param {string}   value - Value to parse.\r\n *\r\n * @returns {number|undefined} The integer component of a pixel string.\r\n */\r\nexport function styleParsePixels(value)\r\n{\r\n   if (typeof value !== 'string') { return void 0; }\r\n\r\n   const isPixels = s_REGEX.test(value);\r\n   const number = parseInt(value);\r\n\r\n   return isPixels && Number.isFinite(number) ? number : void 0;\r\n}\r\n","/**\r\n * Defines the application shell contract. If Svelte components export getter / setters for the following properties\r\n * then that component is considered an application shell.\r\n *\r\n * @type {string[]}\r\n */\r\nconst applicationShellContract = ['elementRoot'];\r\n\r\nObject.freeze(applicationShellContract);\r\n\r\nexport { applicationShellContract };\r\n","import { applicationShellContract } from './applicationShellContract.js';\r\n\r\n/**\r\n * Provides a method to determine if the passed in object is ApplicationShell or TJSApplicationShell.\r\n *\r\n * @param {*}  component - Object / component to test.\r\n *\r\n * @returns {boolean} Whether the component is a ApplicationShell or TJSApplicationShell.\r\n */\r\nexport function isApplicationShell(component)\r\n{\r\n   if (component === null || component === void 0) { return false; }\r\n\r\n   // Get the prototype which is the parent SvelteComponent that has any getter / setters.\r\n   const prototype = Object.getPrototypeOf(component);\r\n\r\n   // Verify the application shell contract. If the accessors (getters / setters) are defined for\r\n   // `applicationShellContract`.\r\n   for (const accessor of applicationShellContract)\r\n   {\r\n      const descriptor = Object.getOwnPropertyDescriptor(prototype, accessor);\r\n      if (descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0) { return false; }\r\n   }\r\n\r\n   return true;\r\n}\r\n","/**\r\n * Provides basic duck typing to determine if the provided function is a constructor function for a Svelte component.\r\n *\r\n * @param {*}  comp - Data to check as a Svelte component.\r\n *\r\n * @returns {boolean} Whether basic duck typing succeeds.\r\n */\r\nexport function isSvelteComponent(comp)\r\n{\r\n   if (comp === null || comp === void 0 || typeof comp !== 'function') { return false; }\r\n\r\n   return typeof window !== void 0 ?\r\n    typeof comp.prototype.$destroy === 'function' && typeof comp.prototype.$on === 'function' : // client-side\r\n     typeof comp.render === 'function'; // server-side\r\n}","import { check_outros, group_outros, transition_out } from 'svelte/internal';\r\n\r\n/**\r\n * Runs outro transition then destroys Svelte component.\r\n *\r\n * Workaround for https://github.com/sveltejs/svelte/issues/4056\r\n *\r\n * @param {*}  instance - A Svelte component.\r\n */\r\nexport async function outroAndDestroy(instance)\r\n{\r\n   return new Promise((resolve) =>\r\n   {\r\n      if (instance.$$.fragment && instance.$$.fragment.o)\r\n      {\r\n         group_outros();\r\n         transition_out(instance.$$.fragment, 0, 0, () =>\r\n         {\r\n            instance.$destroy();\r\n            resolve();\r\n         });\r\n         check_outros();\r\n      }\r\n      else\r\n      {\r\n         instance.$destroy();\r\n         resolve();\r\n      }\r\n   });\r\n}\r\n","import { isSvelteComponent } from './isSvelteComponent.js';\r\n\r\n/**\r\n * Parses a TyphonJS Svelte config object ensuring that classes specified are Svelte components and props are set\r\n * correctly.\r\n *\r\n * @param {object}   config - Svelte config object.\r\n *\r\n * @param {*}        [thisArg] - `This` reference to set for invoking any props function.\r\n *\r\n * @returns {object} The processed Svelte config object.\r\n */\r\nexport function parseSvelteConfig(config, thisArg = void 0)\r\n{\r\n   if (typeof config !== 'object')\r\n   {\r\n      throw new TypeError(`parseSvelteConfig - 'config' is not an object:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (!isSvelteComponent(config.class))\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'class' is not a Svelte component constructor for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (config.hydrate !== void 0 && typeof config.hydrate !== 'boolean')\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'hydrate' is not a boolean for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (config.intro !== void 0 && typeof config.intro !== 'boolean')\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'intro' is not a boolean for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (config.target !== void 0 && typeof config.target !== 'string' && !(config.target instanceof HTMLElement) &&\r\n    !(config.target instanceof ShadowRoot) && !(config.target instanceof DocumentFragment))\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'target' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:\\n${\r\n        JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (config.anchor !== void 0 && typeof config.anchor !== 'string' && !(config.anchor instanceof HTMLElement) &&\r\n    !(config.anchor instanceof ShadowRoot) && !(config.anchor instanceof DocumentFragment))\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'anchor' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:\\n${\r\n        JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (config.context !== void 0 && typeof config.context !== 'function' && !(config.context instanceof Map) &&\r\n    typeof config.context !== 'object')\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'context' is not a Map, function or object for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   // Validate extra TyphonJS options --------------------------------------------------------------------------------\r\n\r\n   // `selectorTarget` optionally stores a target element found in main element.\r\n   if (config.selectorTarget !== void 0 && typeof config.selectorTarget !== 'string')\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'selectorTarget' is not a string for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   // `options` stores `injectApp`, `injectEventbus`, and `selectorElement`.\r\n   if (config.options !== void 0 && typeof config.options !== 'object')\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'options' is not an object for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   // Validate TyphonJS standard options.\r\n   if (config.options !== void 0)\r\n   {\r\n      if (config.options.injectApp !== void 0 && typeof config.options.injectApp !== 'boolean')\r\n      {\r\n         throw new TypeError(\r\n          `parseSvelteConfig - 'options.injectApp' is not a boolean for config:\\n${JSON.stringify(config)}.`);\r\n      }\r\n\r\n      if (config.options.injectEventbus !== void 0 && typeof config.options.injectEventbus !== 'boolean')\r\n      {\r\n         throw new TypeError(\r\n          `parseSvelteConfig - 'options.injectEventbus' is not a boolean for config:\\n${JSON.stringify(config)}.`);\r\n      }\r\n\r\n      // `selectorElement` optionally stores a main element selector to be found in a HTMLElement target.\r\n      if (config.options.selectorElement !== void 0 && typeof config.options.selectorElement !== 'string')\r\n      {\r\n         throw new TypeError(\r\n          `parseSvelteConfig - 'selectorElement' is not a string for config:\\n${JSON.stringify(config)}.`);\r\n      }\r\n   }\r\n\r\n   const svelteConfig = { ...config };\r\n\r\n   // Delete extra Svelte options.\r\n   delete svelteConfig.options;\r\n\r\n   let externalContext = {};\r\n\r\n   // If a context callback function is provided then invoke it with `this` being the Foundry app.\r\n   // If an object is returned it adds the entries to external context.\r\n   if (typeof svelteConfig.context === 'function')\r\n   {\r\n      const contextFunc = svelteConfig.context;\r\n      delete svelteConfig.context;\r\n\r\n      const result = contextFunc.call(thisArg);\r\n      if (typeof result === 'object')\r\n      {\r\n         externalContext = { ...result };\r\n      }\r\n      else\r\n      {\r\n         throw new Error(`parseSvelteConfig - 'context' is a function that did not return an object for config:\\n${\r\n          JSON.stringify(config)}`);\r\n      }\r\n   }\r\n   else if (svelteConfig.context instanceof Map)\r\n   {\r\n      externalContext = Object.fromEntries(svelteConfig.context);\r\n      delete svelteConfig.context;\r\n   }\r\n   else if (typeof svelteConfig.context === 'object')\r\n   {\r\n      externalContext = svelteConfig.context;\r\n      delete svelteConfig.context;\r\n   }\r\n\r\n   // If a props is a function then invoke it with `this` being the Foundry app.\r\n   // If an object is returned set it as the props.\r\n   svelteConfig.props = s_PROCESS_PROPS(svelteConfig.props, thisArg, config);\r\n\r\n   // Process children components attaching to external context.\r\n   if (Array.isArray(svelteConfig.children))\r\n   {\r\n      const children = [];\r\n\r\n      for (let cntr = 0; cntr < svelteConfig.children.length; cntr++)\r\n      {\r\n         const child = svelteConfig.children[cntr];\r\n\r\n         if (!isSvelteComponent(child.class))\r\n         {\r\n            throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for child[${cntr}] for config:\\n${\r\n             JSON.stringify(config)}`);\r\n         }\r\n\r\n         child.props = s_PROCESS_PROPS(child.props, thisArg, config);\r\n\r\n         children.push(child);\r\n      }\r\n\r\n      if (children.length > 0)\r\n      {\r\n         externalContext.children = children;\r\n      }\r\n\r\n      delete svelteConfig.children;\r\n   }\r\n   else if (typeof svelteConfig.children === 'object')\r\n   {\r\n      if (!isSvelteComponent(svelteConfig.children.class))\r\n      {\r\n         throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for children object for config:\\n${\r\n          JSON.stringify(config)}`);\r\n      }\r\n\r\n      svelteConfig.children.props = s_PROCESS_PROPS(svelteConfig.children.props, thisArg, config);\r\n\r\n      externalContext.children = [svelteConfig.children];\r\n      delete svelteConfig.children;\r\n   }\r\n\r\n   if (!(svelteConfig.context instanceof Map))\r\n   {\r\n      svelteConfig.context = new Map();\r\n   }\r\n\r\n   svelteConfig.context.set('external', externalContext);\r\n\r\n   return svelteConfig;\r\n}\r\n\r\n/**\r\n * Processes Svelte props. Potentially props can be a function to invoke with `thisArg`.\r\n *\r\n * @param {object|Function}   props - Svelte props.\r\n *\r\n * @param {*}                 thisArg - `This` reference to set for invoking any props function.\r\n *\r\n * @param {object}            config - Svelte config\r\n *\r\n * @returns {object|void}     Svelte props.\r\n */\r\nfunction s_PROCESS_PROPS(props, thisArg, config)\r\n{\r\n   // If a props is a function then invoke it with `this` being the Foundry app.\r\n   // If an object is returned set it as the props.\r\n   if (typeof props === 'function')\r\n   {\r\n      const result = props.call(thisArg);\r\n      if (typeof result === 'object')\r\n      {\r\n         return result;\r\n      }\r\n      else\r\n      {\r\n         throw new Error(`parseSvelteConfig - 'props' is a function that did not return an object for config:\\n${\r\n          JSON.stringify(config)}`);\r\n      }\r\n   }\r\n   else if (typeof props === 'object')\r\n   {\r\n      return props;\r\n   }\r\n   else if (props !== void 0)\r\n   {\r\n      throw new Error(\r\n       `parseSvelteConfig - 'props' is not a function or an object for config:\\n${JSON.stringify(config)}`);\r\n   }\r\n\r\n   return {};\r\n}","/**\r\n * Provides common object manipulation utilities including depth traversal, obtaining accessors, safely setting values /\r\n * equality tests, and validation.\r\n */\r\n\r\nconst s_TAG_OBJECT = '[object Object]';\r\nconst s_TAG_MAP = '[object Map]';\r\nconst s_TAG_SET = '[object Set]';\r\nconst s_TAG_STRING = '[object String]';\r\n\r\n/**\r\n * @typedef {object} ValidationEntry - Provides data for a validation check.\r\n *\r\n * @property {string}               [type] - Optionally tests with a typeof check.\r\n *\r\n * @property {Array<*>|Function|Set<*>}  [expected] - Optional array, function, or set of expected values to test\r\n * against.\r\n *\r\n * @property {string}               [message] - Optional message to include.\r\n *\r\n * @property {boolean}              [required=true] - When false if the accessor is missing validation is skipped.\r\n *\r\n * @property {boolean}              [error=true] - When true and error is thrown otherwise a boolean is returned.\r\n */\r\n\r\n/**\r\n * Freezes all entries traversed that are objects including entries in arrays.\r\n *\r\n * @param {object|Array}   data - An object or array.\r\n *\r\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\r\n *\r\n * @returns {object|Array} The frozen object.\r\n */\r\nexport function deepFreeze(data, skipFreezeKeys = [])\r\n{\r\n   /* istanbul ignore if */\r\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\r\n\r\n   /* istanbul ignore if */\r\n   if (!Array.isArray(skipFreezeKeys)) { throw new TypeError(`'skipFreezeKeys' is not an 'array'.`); }\r\n\r\n   return _deepFreeze(data, skipFreezeKeys);\r\n}\r\n\r\n/**\r\n * Recursively deep merges all source objects into the target object in place. Like `Object.assign` if you provide `{}`\r\n * as the target a copy is produced. If the target and source property are object literals they are merged.\r\n * Deleting keys is supported by specifying a property starting with `-=`.\r\n *\r\n * @param {object}      target - Target object.\r\n *\r\n * @param {...object}   sourceObj - One or more source objects.\r\n *\r\n * @returns {object}    Target object.\r\n */\r\nexport function deepMerge(target = {}, ...sourceObj)\r\n{\r\n   if (Object.prototype.toString.call(target) !== s_TAG_OBJECT)\r\n   {\r\n      throw new TypeError(`deepMerge error: 'target' is not an 'object'.`);\r\n   }\r\n\r\n   for (let cntr = 0; cntr < sourceObj.length; cntr++)\r\n   {\r\n      if (Object.prototype.toString.call(sourceObj[cntr]) !== s_TAG_OBJECT)\r\n      {\r\n         throw new TypeError(`deepMerge error: 'sourceObj[${cntr}]' is not an 'object'.`);\r\n      }\r\n   }\r\n\r\n   return _deepMerge(target, ...sourceObj);\r\n}\r\n\r\n/**\r\n * Performs a naive depth traversal of an object / array. The data structure _must not_ have circular references.\r\n * The result of the callback function is used to modify in place the given data.\r\n *\r\n * @param {object|Array}   data - An object or array.\r\n *\r\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\r\n *\r\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\r\n *                                  the given data.\r\n *\r\n * @returns {*} The data object.\r\n */\r\nexport function depthTraverse(data, func, modify = false)\r\n{\r\n   /* istanbul ignore if */\r\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\r\n\r\n   /* istanbul ignore if */\r\n   if (typeof func !== 'function') { throw new TypeError(`'func' is not a 'function'.`); }\r\n\r\n   return _depthTraverse(data, func, modify);\r\n}\r\n\r\n/**\r\n * Returns a list of accessor keys by traversing the given object.\r\n *\r\n * @param {object}   data - An object to traverse for accessor keys.\r\n *\r\n * @returns {string[]} Accessor list.\r\n */\r\nexport function getAccessorList(data)\r\n{\r\n   if (typeof data !== 'object') { throw new TypeError(`getAccessorList error: 'data' is not an 'object'.`); }\r\n\r\n   return _getAccessorList(data);\r\n}\r\n\r\n/**\r\n * Tests for whether an object is iterable.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @returns {boolean} Whether object is iterable.\r\n */\r\nexport function isIterable(value)\r\n{\r\n   if (value === null || value === void 0 || typeof value !== 'object') { return false; }\r\n\r\n   return typeof value[Symbol.iterator] === 'function';\r\n}\r\n\r\n/**\r\n * Tests for whether an object is async iterable.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @returns {boolean} Whether value is async iterable.\r\n */\r\nexport function isIterableAsync(value)\r\n{\r\n   if (value === null || value === void 0 || typeof value !== 'object') { return false; }\r\n\r\n   return typeof value[Symbol.asyncIterator] === 'function';\r\n}\r\n\r\n/**\r\n * Tests for whether object is not null and a typeof object.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @returns {boolean} Is it an object.\r\n */\r\nexport function isObject(value)\r\n{\r\n   return value !== null && typeof value === 'object';\r\n}\r\n\r\n/**\r\n * Tests for whether the given value is a plain object.\r\n *\r\n * An object is plain if it is created by either: {}, new Object() or Object.create(null).\r\n *\r\n * @param {*} value - Any value\r\n *\r\n * @returns {boolean} Is it a plain object.\r\n */\r\nexport function isPlainObject(value)\r\n{\r\n   if (Object.prototype.toString.call(value) !== s_TAG_OBJECT) { return false; }\r\n\r\n   const prototype = Object.getPrototypeOf(value);\r\n   return prototype === null || prototype === Object.prototype;\r\n}\r\n\r\n/**\r\n * Safely returns keys on an object or an empty array if not an object.\r\n *\r\n * @param {object} object - An object.\r\n *\r\n * @returns {string[]} Object keys\r\n */\r\nexport function objectKeys(object)\r\n{\r\n   return object !== null && typeof object === 'object' ? Object.keys(object) : [];\r\n}\r\n\r\n/**\r\n * Safely returns an objects size. Note for String objects unicode is not taken into consideration.\r\n *\r\n * @param {object} object - An object.\r\n *\r\n * @returns {number} Size of object.\r\n */\r\nexport function objectSize(object)\r\n{\r\n   if (object === void 0 || object === null || typeof object !== 'object') { return 0; }\r\n\r\n   const tag = Object.prototype.toString.call(object);\r\n\r\n   if (tag === s_TAG_MAP || tag === s_TAG_SET) { return object.size; }\r\n\r\n   if (tag === s_TAG_STRING) { return object.length; }\r\n\r\n   return Object.keys(object).length;\r\n}\r\n\r\n/**\r\n * Provides a way to safely access an objects data / entries given an accessor string which describes the\r\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\r\n * to walk.\r\n *\r\n * @param {object}   data - An object to access entry data.\r\n *\r\n * @param {string}   accessor - A string describing the entries to access.\r\n *\r\n * @param {*}        defaultValue - (Optional) A default value to return if an entry for accessor is not found.\r\n *\r\n * @returns {object} The data object.\r\n */\r\nexport function safeAccess(data, accessor, defaultValue = void 0)\r\n{\r\n   if (typeof data !== 'object') { return defaultValue; }\r\n   if (typeof accessor !== 'string') { return defaultValue; }\r\n\r\n   const access = accessor.split('.');\r\n\r\n   // Walk through the given object by the accessor indexes.\r\n   for (let cntr = 0; cntr < access.length; cntr++)\r\n   {\r\n      // If the next level of object access is undefined or null then return the empty string.\r\n      if (typeof data[access[cntr]] === 'undefined' || data[access[cntr]] === null) { return defaultValue; }\r\n\r\n      data = data[access[cntr]];\r\n   }\r\n\r\n   return data;\r\n}\r\n\r\n/**\r\n * Provides a way to safely batch set an objects data / entries given an array of accessor strings which describe the\r\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\r\n * to walk. If value is an object the accessor will be used to access a target value from `value` which is\r\n * subsequently set to `data` by the given operation. If `value` is not an object it will be used as the target\r\n * value to set across all accessors.\r\n *\r\n * @param {object}         data - An object to access entry data.\r\n *\r\n * @param {Array<string>}  accessors - A string describing the entries to access.\r\n *\r\n * @param {object|*}       value - A new value to set if an entry for accessor is found.\r\n *\r\n * @param {string}         [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\r\n *                                             'set-undefined', 'sub'.\r\n *\r\n * @param {object|*}       [defaultAccessValue=0] - A new value to set if an entry for accessor is found.\r\n *\r\n *\r\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\r\n *                                          automatically.\r\n */\r\nexport function safeBatchSet(data, accessors, value, operation = 'set', defaultAccessValue = 0, createMissing = true)\r\n{\r\n   if (typeof data !== 'object') { throw new TypeError(`safeBatchSet Error: 'data' is not an 'object'.`); }\r\n   if (!Array.isArray(accessors)) { throw new TypeError(`safeBatchSet Error: 'accessors' is not an 'array'.`); }\r\n\r\n   if (typeof value === 'object')\r\n   {\r\n      accessors.forEach((accessor) =>\r\n      {\r\n         const targetValue = safeAccess(value, accessor, defaultAccessValue);\r\n         safeSet(data, accessor, targetValue, operation, createMissing);\r\n      });\r\n   }\r\n   else\r\n   {\r\n      accessors.forEach((accessor) =>\r\n      {\r\n         safeSet(data, accessor, value, operation, createMissing);\r\n      });\r\n   }\r\n}\r\n\r\n/**\r\n * Compares a source object and values of entries against a target object. If the entries in the source object match\r\n * the target object then `true` is returned otherwise `false`. If either object is undefined or null then false\r\n * is returned.\r\n *\r\n * @param {object}   source - Source object.\r\n *\r\n * @param {object}   target - Target object.\r\n *\r\n * @returns {boolean} True if equal.\r\n */\r\nexport function safeEqual(source, target)\r\n{\r\n   if (typeof source === 'undefined' || source === null || typeof target === 'undefined' || target === null)\r\n   {\r\n      return false;\r\n   }\r\n\r\n   const sourceAccessors = getAccessorList(source);\r\n\r\n   for (let cntr = 0; cntr < sourceAccessors.length; cntr++)\r\n   {\r\n      const accessor = sourceAccessors[cntr];\r\n\r\n      const sourceObjectValue = safeAccess(source, accessor);\r\n      const targetObjectValue = safeAccess(target, accessor);\r\n\r\n      if (sourceObjectValue !== targetObjectValue) { return false; }\r\n   }\r\n\r\n   return true;\r\n}\r\n\r\n/**\r\n * Provides a way to safely set an objects data / entries given an accessor string which describes the\r\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\r\n * to walk.\r\n *\r\n * @param {object}   data - An object to access entry data.\r\n *\r\n * @param {string}   accessor - A string describing the entries to access.\r\n *\r\n * @param {*}        value - A new value to set if an entry for accessor is found.\r\n *\r\n * @param {string}   [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\r\n *                                       'set-undefined', 'sub'.\r\n *\r\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\r\n *                                          automatically.\r\n *\r\n * @returns {boolean} True if successful.\r\n */\r\nexport function safeSet(data, accessor, value, operation = 'set', createMissing = true)\r\n{\r\n   if (typeof data !== 'object') { throw new TypeError(`safeSet Error: 'data' is not an 'object'.`); }\r\n   if (typeof accessor !== 'string') { throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`); }\r\n\r\n   const access = accessor.split('.');\r\n\r\n   // Walk through the given object by the accessor indexes.\r\n   for (let cntr = 0; cntr < access.length; cntr++)\r\n   {\r\n      // If data is an array perform validation that the accessor is a positive integer otherwise quit.\r\n      if (Array.isArray(data))\r\n      {\r\n         const number = (+access[cntr]);\r\n\r\n         if (!Number.isInteger(number) || number < 0) { return false; }\r\n      }\r\n\r\n      if (cntr === access.length - 1)\r\n      {\r\n         switch (operation)\r\n         {\r\n            case 'add':\r\n               data[access[cntr]] += value;\r\n               break;\r\n\r\n            case 'div':\r\n               data[access[cntr]] /= value;\r\n               break;\r\n\r\n            case 'mult':\r\n               data[access[cntr]] *= value;\r\n               break;\r\n\r\n            case 'set':\r\n               data[access[cntr]] = value;\r\n               break;\r\n\r\n            case 'set-undefined':\r\n               if (typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = value; }\r\n               break;\r\n\r\n            case 'sub':\r\n               data[access[cntr]] -= value;\r\n               break;\r\n         }\r\n      }\r\n      else\r\n      {\r\n         // If createMissing is true and the next level of object access is undefined then create a new object entry.\r\n         if (createMissing && typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = {}; }\r\n\r\n         // Abort if the next level is null or not an object and containing a value.\r\n         if (data[access[cntr]] === null || typeof data[access[cntr]] !== 'object') { return false; }\r\n\r\n         data = data[access[cntr]];\r\n      }\r\n   }\r\n\r\n   return true;\r\n}\r\n\r\n/**\r\n * Performs bulk setting of values to the given data object.\r\n *\r\n * @param {object}            data - The data object to set data.\r\n *\r\n * @param {object<string, *>} accessorValues - Object of accessor keys to values to set.\r\n *\r\n * @param {string}            [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set', 'sub';\r\n *                                                default (`set`).\r\n *\r\n * @param {boolean}           [createMissing=true] - If true missing accessor entries will be created as objects\r\n *                                                   automatically.\r\n */\r\nexport function safeSetAll(data, accessorValues, operation = 'set', createMissing = true)\r\n{\r\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\r\n   if (typeof accessorValues !== 'object') { throw new TypeError(`'accessorValues' is not an 'object'.`); }\r\n\r\n   for (const accessor of Object.keys(accessorValues))\r\n   {\r\n      if (!accessorValues.hasOwnProperty(accessor)) { continue; } // eslint-disable-line no-prototype-builtins\r\n\r\n      safeSet(data, accessor, accessorValues[accessor], operation, createMissing);\r\n   }\r\n}\r\n\r\n/**\r\n * Performs bulk validation of data given an object, `validationData`, which describes all entries to test.\r\n *\r\n * @param {object}                           data - The data object to test.\r\n *\r\n * @param {object<string, ValidationEntry>}  validationData - Key is the accessor / value is a validation entry.\r\n *\r\n * @param {string}                           [dataName='data'] - Optional name of data.\r\n *\r\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\r\n */\r\nexport function validate(data, validationData = {}, dataName = 'data')\r\n{\r\n   if (typeof data !== 'object') { throw new TypeError(`'${dataName}' is not an 'object'.`); }\r\n   if (typeof validationData !== 'object') { throw new TypeError(`'validationData' is not an 'object'.`); }\r\n\r\n   let result;\r\n\r\n   for (const key of Object.keys(validationData))\r\n   {\r\n      if (!validationData.hasOwnProperty(key)) { continue; } // eslint-disable-line no-prototype-builtins\r\n\r\n      const entry = validationData[key];\r\n\r\n      switch (entry.test)\r\n      {\r\n         case 'array':\r\n            result = validateArray(data, key, entry, dataName);\r\n            break;\r\n\r\n         case 'entry':\r\n            result = validateEntry(data, key, entry, dataName);\r\n            break;\r\n\r\n         case 'entry|array':\r\n            result = validateEntryOrArray(data, key, entry, dataName);\r\n            break;\r\n      }\r\n   }\r\n\r\n   return result;\r\n}\r\n\r\n/**\r\n * Validates all array entries against potential type and expected tests.\r\n *\r\n * @param {object}            data - The data object to test.\r\n *\r\n * @param {string}            accessor - A string describing the entries to access.\r\n *\r\n * @param {object}            opts - Options object.\r\n *\r\n * @param {string}            [opts.type] - Tests with a typeof check.\r\n *\r\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\r\n *\r\n * @param {string}            [opts.message] - Optional message to include.\r\n *\r\n * @param {boolean}           [opts.required] - When false if the accessor is missing validation is skipped.\r\n *\r\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\r\n *\r\n * @param {string}            [dataName='data'] - Optional name of data.\r\n *\r\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\r\n */\r\nexport function validateArray(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\r\n error = true } = {}, dataName = 'data')\r\n{\r\n   const dataArray = safeAccess(data, accessor);\r\n\r\n   // A non-required entry is missing so return without validation.\r\n   if (!required && typeof dataArray === 'undefined') { return true; }\r\n\r\n   if (!Array.isArray(dataArray))\r\n   {\r\n      if (error)\r\n      {\r\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not an 'array'.`);\r\n      }\r\n      else\r\n      {\r\n         return false;\r\n      }\r\n   }\r\n\r\n   if (typeof type === 'string')\r\n   {\r\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\r\n      {\r\n         if (!(typeof dataArray[cntr] === type))\r\n         {\r\n            if (error)\r\n            {\r\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\r\n                dataArray[cntr];\r\n\r\n               throw _validateError(TypeError,\r\n                `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' is not a '${type}'.`);\r\n            }\r\n            else\r\n            {\r\n               return false;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   // If expected is a function then test all array entries against the test function. If expected is a Set then\r\n   // test all array entries for inclusion in the set. Otherwise if expected is a string then test that all array\r\n   // entries as a `typeof` test against expected.\r\n   if (Array.isArray(expected))\r\n   {\r\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\r\n      {\r\n         if (!expected.includes(dataArray[cntr]))\r\n         {\r\n            if (error)\r\n            {\r\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\r\n                dataArray[cntr];\r\n\r\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\r\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\r\n            }\r\n            else\r\n            {\r\n               return false;\r\n            }\r\n         }\r\n      }\r\n   }\r\n   else if (expected instanceof Set)\r\n   {\r\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\r\n      {\r\n         if (!expected.has(dataArray[cntr]))\r\n         {\r\n            if (error)\r\n            {\r\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\r\n                dataArray[cntr];\r\n\r\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\r\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\r\n            }\r\n            else\r\n            {\r\n               return false;\r\n            }\r\n         }\r\n      }\r\n   }\r\n   else if (typeof expected === 'function')\r\n   {\r\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\r\n      {\r\n         try\r\n         {\r\n            const result = expected(dataArray[cntr]);\r\n\r\n            if (typeof result === 'undefined' || !result) { throw new Error(message); }\r\n         }\r\n         catch (err)\r\n         {\r\n            if (error)\r\n            {\r\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\r\n                dataArray[cntr];\r\n\r\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\r\n                dataEntryString}' failed validation: ${err.message}.`);\r\n            }\r\n            else\r\n            {\r\n               return false;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return true;\r\n}\r\n\r\n/**\r\n * Validates data entry with a typeof check and potentially tests against the values in any given expected set.\r\n *\r\n * @param {object}            data - The object data to validate.\r\n *\r\n * @param {string}            accessor - A string describing the entries to access.\r\n *\r\n * @param {object}            opts - Options object\r\n *\r\n * @param {string}            [opts.type] - Tests with a typeof check.\r\n *\r\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\r\n *\r\n * @param {string}            [opts.message] - Optional message to include.\r\n *\r\n * @param {boolean}           [opts.required=true] - When false if the accessor is missing validation is skipped.\r\n *\r\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\r\n *\r\n * @param {string}            [dataName='data'] - Optional name of data.\r\n *\r\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\r\n */\r\nexport function validateEntry(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\r\n error = true } = {}, dataName = 'data')\r\n{\r\n   const dataEntry = safeAccess(data, accessor);\r\n\r\n   // A non-required entry is missing so return without validation.\r\n   if (!required && typeof dataEntry === 'undefined') { return true; }\r\n\r\n   if (type && typeof dataEntry !== type)\r\n   {\r\n      if (error)\r\n      {\r\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not a '${type}'.`);\r\n      }\r\n      else\r\n      {\r\n         return false;\r\n      }\r\n   }\r\n\r\n   if ((expected instanceof Set && !expected.has(dataEntry)) ||\r\n    (Array.isArray(expected) && !expected.includes(dataEntry)))\r\n   {\r\n      if (error)\r\n      {\r\n         const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\r\n\r\n         throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' is not an expected value: ${\r\n          JSON.stringify(expected)}.`);\r\n      }\r\n      else\r\n      {\r\n         return false;\r\n      }\r\n   }\r\n   else if (typeof expected === 'function')\r\n   {\r\n      try\r\n      {\r\n         const result = expected(dataEntry);\r\n\r\n         if (typeof result === 'undefined' || !result) { throw new Error(message); }\r\n      }\r\n      catch (err)\r\n      {\r\n         if (error)\r\n         {\r\n            const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\r\n\r\n            throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' failed to validate: ${\r\n             err.message}.`);\r\n         }\r\n         else\r\n         {\r\n            return false;\r\n         }\r\n      }\r\n   }\r\n\r\n   return true;\r\n}\r\n\r\n/**\r\n * Dispatches validation of data entry to string or array validation depending on data entry type.\r\n *\r\n * @param {object}            data - The data object to test.\r\n *\r\n * @param {string}            accessor - A string describing the entries to access.\r\n *\r\n * @param {ValidationEntry}   [entry] - A validation entry.\r\n *\r\n * @param {string}            [dataName='data'] - Optional name of data.\r\n *\r\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\r\n */\r\nexport function validateEntryOrArray(data, accessor, entry, dataName = 'data')\r\n{\r\n   const dataEntry = safeAccess(data, accessor);\r\n\r\n   let result;\r\n\r\n   if (Array.isArray(dataEntry))\r\n   {\r\n      result = validateArray(data, accessor, entry, dataName);\r\n   }\r\n   else\r\n   {\r\n      result = validateEntry(data, accessor, entry, dataName);\r\n   }\r\n\r\n   return result;\r\n}\r\n\r\n// Module private ---------------------------------------------------------------------------------------------------\r\n\r\n/**\r\n * Private implementation of depth traversal.\r\n *\r\n * @param {object|Array}   data - An object or array.\r\n *\r\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\r\n *\r\n * @returns {*} The frozen object.\r\n * @ignore\r\n * @private\r\n */\r\nfunction _deepFreeze(data, skipFreezeKeys)\r\n{\r\n   if (Array.isArray(data))\r\n   {\r\n      for (let cntr = 0; cntr < data.length; cntr++) { _deepFreeze(data[cntr], skipFreezeKeys); }\r\n   }\r\n   else if (typeof data === 'object')\r\n   {\r\n      for (const key in data)\r\n      {\r\n         // eslint-disable-next-line no-prototype-builtins\r\n         if (data.hasOwnProperty(key) && !skipFreezeKeys.includes(key)) { _deepFreeze(data[key], skipFreezeKeys); }\r\n      }\r\n   }\r\n\r\n   return Object.freeze(data);\r\n}\r\n\r\n/**\r\n * Internal implementation for `deepMerge`.\r\n *\r\n * @param {object}      target - Target object.\r\n *\r\n * @param {...object}   sourceObj - One or more source objects.\r\n *\r\n * @returns {object}    Target object.\r\n */\r\nfunction _deepMerge(target = {}, ...sourceObj)\r\n{\r\n   // Iterate and merge all source objects into target.\r\n   for (let cntr = 0; cntr < sourceObj.length; cntr++)\r\n   {\r\n      const obj = sourceObj[cntr];\r\n\r\n      for (const prop in obj)\r\n      {\r\n         if (Object.prototype.hasOwnProperty.call(obj, prop))\r\n         {\r\n            // Handle the special property starting with '-=' to delete keys.\r\n            if (prop.startsWith('-='))\r\n            {\r\n               delete target[prop.slice(2)];\r\n               continue;\r\n            }\r\n\r\n            // If target already has prop and both target[prop] and obj[prop] are object literals then merge them\r\n            // otherwise assign obj[prop] to target[prop].\r\n            target[prop] = Object.prototype.hasOwnProperty.call(target, prop) && target[prop]?.constructor === Object &&\r\n            obj[prop]?.constructor === Object ? _deepMerge({}, target[prop], obj[prop]) : obj[prop];\r\n         }\r\n      }\r\n   }\r\n\r\n   return target;\r\n}\r\n\r\n/**\r\n * Private implementation of depth traversal.\r\n *\r\n * @param {object|Array}   data - An object or array.\r\n *\r\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\r\n *\r\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\r\n *                                  the given data.\r\n *\r\n * @returns {*} The data object.\r\n * @ignore\r\n * @private\r\n */\r\nfunction _depthTraverse(data, func, modify)\r\n{\r\n   if (modify)\r\n   {\r\n      if (Array.isArray(data))\r\n      {\r\n         for (let cntr = 0; cntr < data.length; cntr++)\r\n         {\r\n            data[cntr] = _depthTraverse(data[cntr], func, modify);\r\n         }\r\n      }\r\n      else if (typeof data === 'object')\r\n      {\r\n         for (const key in data)\r\n         {\r\n            // eslint-disable-next-line no-prototype-builtins\r\n            if (data.hasOwnProperty(key)) { data[key] = _depthTraverse(data[key], func, modify); }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         data = func(data);\r\n      }\r\n   }\r\n   else\r\n   {\r\n      if (Array.isArray(data))\r\n      {\r\n         for (let cntr = 0; cntr < data.length; cntr++) { _depthTraverse(data[cntr], func, modify); }\r\n      }\r\n      else if (typeof data === 'object')\r\n      {\r\n         for (const key in data)\r\n         {\r\n            // eslint-disable-next-line no-prototype-builtins\r\n            if (data.hasOwnProperty(key)) { _depthTraverse(data[key], func, modify); }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         func(data);\r\n      }\r\n   }\r\n\r\n   return data;\r\n}\r\n\r\n/**\r\n * Private implementation of `getAccessorList`.\r\n *\r\n * @param {object}   data - An object to traverse.\r\n *\r\n * @returns {string[]} Accessor list.\r\n * @ignore\r\n * @private\r\n */\r\nfunction _getAccessorList(data)\r\n{\r\n   const accessors = [];\r\n\r\n   for (const key in data)\r\n   {\r\n      if (data.hasOwnProperty(key)) // eslint-disable-line no-prototype-builtins\r\n      {\r\n         if (typeof data[key] === 'object')\r\n         {\r\n            const childKeys = _getAccessorList(data[key]);\r\n\r\n            childKeys.forEach((childKey) =>\r\n            {\r\n               accessors.push(Array.isArray(childKey) ? `${key}.${childKey.join('.')}` : `${key}.${childKey}`);\r\n            });\r\n         }\r\n         else\r\n         {\r\n            accessors.push(key);\r\n         }\r\n      }\r\n   }\r\n\r\n   return accessors;\r\n}\r\n\r\n/**\r\n * Creates a new error of type `clazz` adding the field `_objectValidateError` set to true.\r\n *\r\n * @param {Error}    clazz - Error class to instantiate.\r\n *\r\n * @param {string}   message - An error message.\r\n *\r\n * @returns {*} Error of the clazz.\r\n * @ignore\r\n * @private\r\n */\r\nfunction _validateError(clazz, message = void 0)\r\n{\r\n   const error = new clazz(message);\r\n   error._objectValidateError = true;\r\n   return error;\r\n}\r\n"],"names":[],"mappings":"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"}